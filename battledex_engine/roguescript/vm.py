"""
The RogueScript Virtual Machine.

Executes bytecode Chunks generated by the Compiler.
This is a simple stack-based VM with a call stack.
"""

from .bytecode import Chunk, OpCode
from .compiler import Compiler
from .errors import ParseError, CompileError, RogueScriptRuntimeError
from .lexer import Lexer
from .parser import Parser
# Import from the new function.py file
from .function import RogueScriptFunction, NativeFunction
from enum import Enum, auto
from dataclasses import dataclass
import time # For a native 'clock' function

class InterpretResult(Enum):
    OK = auto()
    COMPILE_ERROR = auto()
    RUNTIME_ERROR = auto()

# RogueScriptFunction and NativeFunction are now in function.py

@dataclass
class CallFrame:
    """Represents a single active function call."""
    function: RogueScriptFunction
    ip: int = 0
    # Index into the VM's stack where this function's
    # local variables begin.
    stack_slot: int = 0
    
    def current_line(self) -> int:
        """Get line number for the *previous* instruction."""
        # Safe-guard for ip=0
        if self.ip == 0:
            return self.function.chunk.lines[0] if self.function.chunk.lines else 1
        return self.function.chunk.lines[self.ip - 1]

# --- Native Functions ---

def native_clock(args: list) -> float:
    """Native fn: return current system time."""
    return time.time()

def native_use_move(args: list) -> str:
    """
    BATTLEDEX HOOK (EXAMPLE)
    This is a placeholder. You would replace this with a method
    on your 'battledex-engine' that actually performs the move.
    """
    if not args:
        return "use_move() requires 1 argument (move_name)."
    move_name = str(args[0])
    print(f"[BATTLEDEX_ENGINE] Using move: {move_name}")
    # In your real engine, this might return True/False on success
    return f"Used {move_name}!"


class VirtualMachine:
    """The engine that runs RogueScript bytecode."""
    
    STACK_MAX = 256 * 64 # Max stack depth
    FRAMES_MAX = 64      # Max call stack depth

    def __init__(self):
        self.frames: list[CallFrame] = []
        self.stack: list[any] = []
        self.globals: dict[str, any] = {}
        
        # --- Register Native Functions ---
        self._define_native("clock", native_clock)
        self._define_native("use_move", native_use_move)
        # Add more hooks here!
        # self._define_native("get_hp", ...)
        # self._define_native("get_opponent_speed", ...)

    def _define_native(self, name: str, function: callable):
        self.globals[name] = NativeFunction(name, function)

    def interpret(self, source: str) -> (InterpretResult, any):
        """
        The main public-facing method.
        Compiles and runs a script, returning the result.
        """
        try:
            lexer = Lexer(source)
            tokens = lexer.get_all_tokens()
            
            parser = Parser(tokens)
            program = parser.parse()
            if program is None:
                return (InterpretResult.COMPILE_ERROR, None)

            compiler = Compiler()
            main_function = compiler.compile(program)
            
            if main_function is None:
                return (InterpretResult.COMPILE_ERROR, None)
            
            # --- Setup VM state ---
            self.stack = []
            self.frames = []
            
            # Push the main <script> function onto the stack
            # as the first thing to be called.
            self.push(main_function)
            # Call it
            self._call(main_function, 0)
            
            result, value = self.run()
            return (result, value)

        except (ParseError, CompileError) as e:
            # These are now raised, not just printed
            print(e)
            return (InterpretResult.COMPILE_ERROR, None)
        except RogueScriptRuntimeError as e:
            self._print_stack_trace(e)
            return (InterpretResult.RUNTIME_ERROR, None)
            
    def run(self) -> (InterpretResult, any):
        """The main execution loop of the VM."""
        
        while True:
            # Get the *current* frame. It can change!
            frame = self.frames[-1]
            
            # --- Debugging ---
            # self._debug_trace_execution(frame)
            
            instruction = self._read_byte(frame)
            op = OpCode(instruction) # Convert int back to OpCode

            if op == OpCode.OP_RETURN:
                result = self.pop() # Get return value
                frame_to_pop = self.frames.pop()
                
                # If this was the *last* frame, the script is done.
                if not self.frames:
                    self.pop() # Pop the main script function
                    return (InterpretResult.OK, result) # All done!
                
                # Discard the function's stack frame
                self.stack = self.stack[:frame_to_pop.stack_slot]
                self.push(result) # Push the return value

            # --- Constants & Literals ---
            elif op == OpCode.OP_PUSH_CONST:
                constant = self._read_constant(frame)
                self.push(constant)
            elif op == OpCode.OP_NIL: self.push(None)
            elif op == OpCode.OP_TRUE: self.push(True)
            elif op == OpCode.OP_FALSE: self.push(False)
            elif op == OpCode.OP_POP: self.pop()
            
            # --- Variables ---
            elif op == OpCode.OP_DEFINE_GLOBAL:
                name = self._read_constant(frame)
                self.globals[name] = self.peek(0)
                self.pop()
            elif op == OpCode.OP_GET_GLOBAL:
                name = self._read_constant(frame)
                value = self.globals.get(name)
                if value is None:
                    return self._runtime_error(f"Undefined global variable '{name}'.")
                self.push(value)
            elif op == OpCode.OP_SET_GLOBAL:
                name = self._read_constant(frame)
                if name not in self.globals:
                    return self._runtime_error(f"Undefined global variable '{name}'.")
                self.globals[name] = self.peek(0) # Don't pop
            elif op == OpCode.OP_GET_LOCAL:
                slot = self._read_byte(frame)
                self.push(self.stack[frame.stack_slot + slot])
            elif op == OpCode.OP_SET_LOCAL:
                slot = self._read_byte(frame)
                self.stack[frame.stack_slot + slot] = self.peek(0)

            # --- Unary Ops ---
            elif op == OpCode.OP_NEGATE:
                if not isinstance(self.peek(0), (int, float)):
                    return self._runtime_error("Operand must be a number.")
                self.push(-self.pop())
            
            elif op == OpCode.OP_NOT:
                self.push(self._is_falsy(self.pop()))
            
            # --- Binary Ops ---
            elif op in (OpCode.OP_ADD, OpCode.OP_SUBTRACT, OpCode.OP_MULTIPLY, 
                         OpCode.OP_DIVIDE, OpCode.OP_GREATER, OpCode.OP_LESS):
                
                b = self.peek(0)
                a = self.peek(1)

                if op == OpCode.OP_ADD:
                    if isinstance(a, (int, float)) and isinstance(b, (int, float)):
                        result = a + b
                    elif isinstance(a, str) and isinstance(b, str):
                        result = a + b
                    else:
                        return self._runtime_error("Operands must be two numbers or two strings.")
                
                # All other ops must be numbers
                elif not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
                    return self._runtime_error("Operands must be numbers.")
                
                elif op == OpCode.OP_SUBTRACT: result = a - b
                elif op == OpCode.OP_MULTIPLY: result = a * b
                elif op == OpCode.OP_DIVIDE:
                    if b == 0:
                        return self._runtime_error("Division by zero.")
                    result = a / b
                elif op == OpCode.OP_GREATER: result = a > b
                elif op == OpCode.OP_LESS:   result = a < b
                
                self.pop()
                self.pop()
                self.push(result)
                
            elif op == OpCode.OP_EQUAL:
                b = self.pop()
                a = self.pop()
                self.push(a == b)
                
            # --- Control Flow ---
            elif op == OpCode.OP_JUMP:
                offset = self._read_short(frame)
                frame.ip += offset
            elif op == OpCode.OP_JUMP_IF_FALSE:
                offset = self._read_short(frame)
                if self._is_falsy(self.peek(0)):
                    frame.ip += offset
            elif op == OpCode.OP_LOOP:
                offset = self._read_short(frame)
                frame.ip -= offset # Jump *backward*

            # --- Statements ---
            elif op == OpCode.OP_PRINT:
                print(self.pop())
                
            # --- Functions ---
            elif op == OpCode.OP_CALL:
                arg_count = self._read_byte(frame)
                callee = self.peek(arg_count) # Callee is below args
                
                if not self._call(callee, arg_count):
                    return (InterpretResult.RUNTIME_ERROR, None)
                
    # --- Call Helper ---
    
    def _call(self, callee: any, arg_count: int) -> bool:
        if isinstance(callee, RogueScriptFunction):
            if arg_count != callee.arity:
                self._runtime_error(f"Expected {callee.arity} arguments but got {arg_count}.")
                return False
            
            if len(self.frames) == self.FRAMES_MAX:
                self._runtime_error("Stack overflow (call stack).")
                return False
                
            frame = CallFrame(
                function=callee,
                ip=0,
                # Set the new frame's stack base *above* the args
                stack_slot=len(self.stack) - arg_count
            )
            self.frames.append(frame)
            return True
            
        elif isinstance(callee, NativeFunction):
            # Get args from the top of the stack
            args = self.stack[len(self.stack) - arg_count:]
            
            try:
                result = callee.callable(args)
            except Exception as e:
                self._runtime_error(f"Native function '{callee.name}' failed: {e}")
                return False
                
            # Pop callee + args
            self.stack = self.stack[:len(self.stack) - (arg_count + 1)]
            self.push(result) # Push the native result
            return True
            
        else:
            self._runtime_error("Can only call functions.")
            return False

    # --- Stack Helpers ---
    
    def push(self, value: any):
        if len(self.stack) >= self.STACK_MAX:
            raise RogueScriptRuntimeError("Stack overflow.", self.frames[-1].current_line())
        self.stack.append(value)
        
    def pop(self) -> any:
        if not self.stack:
            raise RogueScriptRuntimeError("Stack underflow.", self.frames[-1].current_line())
        return self.stack.pop()

    def peek(self, distance: int) -> any:
        """Look at a value on the stack without popping."""
        if len(self.stack) <= distance:
            raise RogueScriptRuntimeError("Stack underflow on peek.", self.frames[-1].current_line())
        return self.stack[-(distance + 1)]

    def _is_falsy(self, value: any) -> bool:
        """Defines 'falsiness' in RogueScript."""
        return value is None or value is False

    # --- Bytecode Reader Helpers ---

    def _read_byte(self, frame: CallFrame) -> int:
        byte = frame.function.chunk.code[frame.ip]
        frame.ip += 1
        return byte

    def _read_short(self, frame: CallFrame) -> int:
        """Reads a 16-bit offset."""
        high = self._read_byte(frame)
        low = self._read_byte(frame)
        return (high << 8) | low

    def _read_constant(self, frame: CallFrame) -> any:
        const_index = self._read_byte(frame)
        return frame.function.chunk.constants[const_index]

    # --- Error and Debugging ---
    
    def _runtime_error(self, message: str) -> (InterpretResult, any):
        line = self.frames[-1].current_line()
        raise RogueScriptRuntimeError(message, line)

    def _print_stack_trace(self, error: RogueScriptRuntimeError):
        print(error) # Print the main error message
        
        # Walk the call stack *backward*
        for frame in reversed(self.frames):
            line = frame.current_line()
            func_name = frame.function.name
            print(f"  [line {line}] in {func_name}()")

    def _debug_trace_execution(self, frame: CallFrame):
        """A useful debug print-out for tracing."""
        op_line = f"[IP {frame.ip:04d} L{frame.current_line():>3}] "
        op_code = OpCode(frame.function.chunk.code[frame.ip])
        
        if op_code == OpCode.OP_PUSH_CONST:
            const_index = frame.function.chunk.code[frame.ip + 1]
            value = frame.function.chunk.constants[const_index]
            op_line += f"OP_PUSH_CONST ({const_index}) -> {value}"
        elif op_code == OpCode.OP_GET_GLOBAL:
            const_index = frame.function.chunk.code[frame.ip + 1]
            name = frame.function.chunk.constants[const_index]
            op_line += f"OP_GET_GLOBAL ({const_index}) -> {name}"
        elif op_code == OpCode.OP_JUMP or op_code == OpCode.OP_JUMP_IF_FALSE:
            high = frame.function.chunk.code[frame.ip + 1]
            low = frame.function.chunk.code[frame.ip + 2]
            offset = (high << 8) | low
            op_line += f"{op_code.name} -> (to IP {frame.ip + 3 + offset})"
        else:
            op_line += op_code.name
            
        print(f"{op_line:<40} STACK: {self.stack}")


