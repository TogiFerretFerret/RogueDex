"""
The RogueScript Virtual Machine.

Executes bytecode Chunks generated by the Compiler.
This is a simple stack-based VM with a call stack.

FIX: This version's interpret() method now re-raises
RogueScriptRuntimeError so that the test harness can
catch it.
"""

from .bytecode import Chunk, OpCode
from .compiler import Compiler
from .errors import ParseError, CompileError, RogueScriptRuntimeError
from .lexer import Lexer
from .parser import Parser
from .function import RogueScriptFunction, NativeFunction
from enum import Enum, auto
from dataclasses import dataclass
import time # For a native 'clock' function

class InterpretResult(Enum):
    OK = auto()
    COMPILE_ERROR = auto()
    RUNTIME_ERROR = auto()

@dataclass
class CallFrame:
    """Represents a single active function call."""
    function: RogueScriptFunction
    ip: int = 0
    # Index into the VM's stack where this function's
    # local variables begin.
    stack_slot: int = 0
    
    def current_line(self) -> int:
        """Get line number for the *previous* instruction."""
        # Safe-guard for ip=0
        if self.ip == 0:
            return self.function.chunk.lines[0] if self.function.chunk.lines else 1
        return self.function.chunk.lines[self.ip - 1]

# --- Native Functions ---

def native_clock(args: list) -> float:
    """Native fn: return current system time."""
    return time.time()

def native_use_move(args: list) -> str:
    """
    BATTLEDEX HOOK (EXAMPLE)
    This is a placeholder. You would replace this with a method
    on your 'battledex-engine' that actually performs the move.
    """
    if not args:
        return "use_move() requires 1 argument (move_name)."
    move_name = str(args[0])
    print(f"[BATTLEDEX_ENGINE] Using move: {move_name}")
    # In your real engine, this might return True/False on success
    return f"Used {move_name}!"


class VirtualMachine:
    """The engine that runs RogueScript bytecode."""
    
    STACK_MAX = 256 * 64 # Max stack depth
    FRAMES_MAX = 64      # Max call stack depth

    def __init__(self):
        self.frames: list[CallFrame] = []
        self.stack: list[any] = []
        self.globals: dict[str, any] = {}
        
        # --- Register Native Functions ---
        self._define_native("clock", native_clock)
        self._define_native("use_move", native_use_move)
        # Add more hooks here!
        # self._define_native("get_hp", ...)
        # self._define_native("get_opponent_speed", ...)

    def _define_native(self, name: str, function: callable):
        self.globals[name] = NativeFunction(name, function)

    def interpret(self, source: str) -> (InterpretResult, any):
        """
        The main public-facing method.
        Compiles and runs a script, returning the result.
        """
        try:
            lexer = Lexer(source)
            tokens = lexer.get_all_tokens()
            
            parser = Parser(tokens)
            program = parser.parse()
            if program is None:
                # Parser detected an error and returned None
                return (InterpretResult.COMPILE_ERROR, None)

            compiler = Compiler()
            main_function = compiler.compile(program)
            
            if main_function is None:
                return (InterpretResult.COMPILE_ERROR, None)
            
            # --- Setup VM state ---
            self.stack = []
            self.frames = []
            
            # Push the main <script> function onto the stack
            # as the first thing to be called.
            self.push(main_function)
            # Call it
            self._call(main_function, 0)
            
            # The 'run' method will raise RogueScriptRuntimeError
            # on its own. We let it propagate up to the test harness.
            result, value = self.run()
            return (result, value)

        except (ParseError, CompileError) as e:
            # Print the compile-time error
            print(e)
            return (InterpretResult.COMPILE_ERROR, None)
        except RogueScriptRuntimeError as e:
            # The run loop raised an error. Print the trace.
            self._print_stack_trace(e)
            # FIX: Re-raise it for the test harness to catch
            raise e
            
    def run(self) -> (InterpretResult, any):
        """The main execution loop of the VM."""
        
        # This loop will be exited by a RogueScriptRuntimeError
        # or when the last frame returns.
        
        while True:
            # Get the *current* frame. It can change!
            frame = self.frames[-1]
            
            # --- Debugging ---
            # self._debug_trace_execution(frame)
            
            instruction = self._read_byte(frame)
            op = OpCode(instruction) # Convert int back to OpCode

            if op == OpCode.OP_RETURN:
                result = self.pop() # Get return value
                frame_to_pop = self.frames.pop()
                
                # If this was the *last* frame, the script is done.
                if not self.frames:
                    self.pop() # Pop the main script function
                    return (InterpretResult.OK, result) # All done!
                
                # Discard the function's stack frame and args
                self.stack = self.stack[:frame_to_pop.stack_slot]
                self.push(result) # Push the return value

            # --- Constants & Literals ---
            elif op == OpCode.OP_PUSH_CONST:
                constant = self._read_constant(frame)
                self.push(constant)
            elif op == OpCode.OP_NIL: self.push(None)
            elif op == OpCode.OP_TRUE: self.push(True)
            elif op == OpCode.OP_FALSE: self.push(False)
            elif op == OpCode.OP_POP: self.pop()
            
            # --- Variables ---
            elif op == OpCode.OP_DEFINE_GLOBAL:
                name = self._read_constant(frame)
                self.globals[name] = self.peek(0)
                self.pop()
            elif op == OpCode.OP_GET_GLOBAL:
                name = self._read_constant(frame)
                # FIX: Check for existence *before* getting
                if name not in self.globals:
                    self._runtime_error(f"Undefined global variable '{name}'.")
                value = self.globals.get(name)
                self.push(value)
            elif op == OpCode.OP_SET_GLOBAL:
                name = self._read_constant(frame)
                if name not in self.globals:
                    self._runtime_error(f"Undefined global variable '{name}'.")
                self.globals[name] = self.peek(0) # Don't pop
            elif op == OpCode.OP_GET_LOCAL:
                slot = self._read_byte(frame)
                self.push(self.stack[frame.stack_slot + slot])
            elif op == OpCode.OP_SET_LOCAL:
                slot = self._read_byte(frame)
                self.stack[frame.stack_slot + slot] = self.peek(0)

            # --- Unary Ops ---
            elif op == OpCode.OP_NEGATE:
                if not isinstance(self.peek(0), (int, float)):
                    self._runtime_error("Operand must be a number.")
                self.push(-self.pop())
            
            elif op == OpCode.OP_NOT:
                self.push(self._is_falsy(self.pop()))
            
            # --- Binary Ops ---
            elif op in (OpCode.OP_ADD, OpCode.OP_SUBTRACT, OpCode.OP_MULTIPLY, 
                        OpCode.OP_DIVIDE, OpCode.OP_GREATER, OpCode.OP_LESS):
                
                b = self.peek(0)
                a = self.peek(1)

                if op == OpCode.OP_ADD:
                    if isinstance(a, (int, float)) and isinstance(b, (int, float)):
                        result = a + b
                    elif isinstance(a, str) and isinstance(b, str):
                        result = a + b
                    else:
                        self._runtime_error("Operands must be two numbers or two strings.")
                
                else: # All other ops must be numbers
                    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
                        self._runtime_error("Operands must be numbers.")
                    
                    if op == OpCode.OP_SUBTRACT: result = a - b
                    elif op == OpCode.OP_MULTIPLY: result = a * b
                    elif op == OpCode.OP_DIVIDE:
                        if b == 0:
                            self._runtime_error("Division by zero.")
                        result = a / b
                    elif op == OpCode.OP_GREATER: result = a > b
                    elif op == OpCode.OP_LESS:   result = a < b
                
                self.pop()
                self.pop()
                self.push(result)
                
            elif op == OpCode.OP_EQUAL:
                b = self.pop()
                a = self.pop()
                self.push(a == b)
                
            # --- Control Flow ---
            elif op == OpCode.OP_JUMP:
                offset = self._read_short(frame)
                frame.ip += offset
            elif op == OpCode.OP_JUMP_IF_FALSE:
                offset = self._read_short(frame)
                if self._is_falsy(self.peek(0)):
                    frame.ip += offset
            elif op == OpCode.OP_LOOP:
                offset = self._read_short(frame)
                frame.ip -= offset # Jump *backward*

            # --- Statements ---
            elif op == OpCode.OP_PRINT:
                print(self.pop())
                
            # --- Functions ---
            elif op == OpCode.OP_CALL:
                arg_count = self._read_byte(frame)
                callee = self.peek(arg_count) # Callee is below args
                
                if not self._call(callee, arg_count):
                    # _call will raise its own error
                    pass
            
            else:
                self._runtime_error(f"Unknown opcode {op}")
            
    # --- Call Helper ---
    
    def _call(self, callee: any, arg_count: int) -> bool:
        if isinstance(callee, RogueScriptFunction):
            if arg_count != callee.arity:
                self._runtime_error(f"Expected {callee.arity} arguments but got {arg_count}.")
                return False
            
            if len(self.frames) == self.FRAMES_MAX:
                self._runtime_error("Stack overflow (call stack).")
                return False
                
            frame = CallFrame(
                function=callee,
                ip=0,
                # FIX: slot is *below* callee and args
                stack_slot=len(self.stack) - arg_count - 1 
            )
            self.frames.append(frame)
            return True
            
        elif isinstance(callee, NativeFunction):
            # Get args from the top of the stack
            args = self.stack[len(self.stack) - arg_count:]
            
            try:
                result = callee.callable(args)
            except Exception as e:
                self._runtime_error(f"Native function '{callee.name}' failed: {e}")
                return False
                
            # Pop callee + args
            self.stack = self.stack[:len(self.stack) - (arg_count + 1)]
            self.push(result) # Push the native result
            return True
            
        else:
            self._runtime_error(f"Can only call functions (got {type(callee)}).")
            return False

    # --- Stack Helpers ---
    
    def push(self, value: any):
        if len(self.stack) >= self.STACK_MAX:
            # Raise, don't return
            self._runtime_error("Stack overflow.")
        self.stack.append(value)
        
    def pop(self) -> any:
        if not self.stack:
            self._runtime_error("Stack underflow.")
        return self.stack.pop()

    def peek(self, distance: int) -> any:
        """Look at a value on the stack without popping."""
        if len(self.stack) <= distance:
            self._runtime_error("Stack underflow on peek.")
        return self.stack[-(distance + 1)]

    def _is_falsy(self, value: any) -> bool:
        """Defines 'falsiness' in RogueScript."""
        return value is None or value is False

    # --- Bytecode Reader Helpers ---

    def _read_byte(self, frame: CallFrame) -> int:
        byte = frame.function.chunk.code[frame.ip]
        frame.ip += 1
        return byte

    def _read_short(self, frame: CallFrame) -> int:
        """Reads a 16-bit offset."""
        high = self._read_byte(frame)
        low = self._read_byte(frame)
        return (high << 8) | low

    def _read_constant(self, frame: CallFrame) -> any:
        const_index = self._read_byte(frame)
        return frame.function.chunk.constants[const_index]

    # --- Error and Debugging ---
    
    def _runtime_error(self, message: str):
        """Raises a RogueScriptRuntimeError."""
        line = self.frames[-1].current_line()
        raise RogueScriptRuntimeError(message, line)

    def _print_stack_trace(self, error: RogueScriptRuntimeError):
        print(error) # Print the main error message
        
        # Walk the call stack *backward*
        for frame in reversed(self.frames):
            line = frame.current_line()
            # Handle error at the very start of a function
            if line == 0 and len(frame.function.chunk.lines) > 0:
                line = frame.function.chunk.lines[0]
                
            func_name = frame.function.name
            if not func_name:
                func_name = "<script>"
            print(f"  [line {line}] in {func_name}()")

    def _debug_trace_execution(self, frame: CallFrame):
        """A useful debug print-out for tracing."""
        op_line = f"[IP {frame.ip:04d} L{frame.current_line():>3}] "
        
        try:
            op_code = OpCode(frame.function.chunk.code[frame.ip])
        except IndexError:
            print(f"{op_line} END OF CHUNK")
            return
        except ValueError:
            print(f"{op_line} UNKNOWN OPCODE {frame.function.chunk.code[frame.ip]}")
            return

        
        if op_code == OpCode.OP_PUSH_CONST:
            const_index = frame.function.chunk.code[frame.ip + 1]
            value = frame.function.chunk.constants[const_index]
            op_line += f"OP_PUSH_CONST ({const_index}) -> {value}"
        elif op_code == OpCode.OP_GET_GLOBAL:
            const_index = frame.function.chunk.code[frame.ip + 1]
            name = frame.function.chunk.constants[const_index]
            op_line += f"OP_GET_GLOBAL ({const_index}) -> {name}"
        elif op_code == OpCode.OP_JUMP or op_code == OpCode.OP_JUMP_IF_FALSE:
            high = frame.function.chunk.code[frame.ip + 1]
            low = frame.function.chunk.code[frame.ip + 2]
            offset = (high << 8) | low
            op_line += f"{op_code.name} -> (to IP {frame.ip + 3 + offset})"
        else:
            op_line += op_code.name
            
        print(f"{op_line:<40} STACK: {self.stack}")


