"""
Defines all the nodes for the Abstract Syntax Tree (AST).

The AST is the hierarchical, tree-based representation of the
source code that is generated by the Parser and consumed by
the Compiler (and ASTPrinter).
"""
from __future__ import annotations
from abc import ABC, abstractmethod
from .lexer import Token

# --- Base Classes ---
# FIX: Added this base class to fix all AttributeError issues.
class ASTNode(ABC):
    """Base class for all nodes in the AST."""
    @abstractmethod
    def accept(self, visitor):
        pass

class Expr(ASTNode):
    """Base class for all expression nodes."""
    @abstractmethod
    def accept(self, visitor: 'ExprVisitor'):
        pass

class Stmt(ASTNode):
    """Base class for all statement nodes."""
    @abstractmethod
    def accept(self, visitor: 'StmtVisitor'):
        pass

# --- Visitor Interfaces ---
# These define the Visitor pattern for operating on the AST.

class ExprVisitor(ABC):
    @abstractmethod
    def visit_binary_expr(self, expr: 'Binary'):
        pass
    @abstractmethod
    def visit_unary_expr(self, expr: 'Unary'):
        pass
    @abstractmethod
    def visit_literal_expr(self, expr: 'Literal'):
        pass
    @abstractmethod
    def visit_grouping_expr(self, expr: 'Grouping'):
        pass
    @abstractmethod
    def visit_variable_expr(self, expr: 'VariableExpr'):
        pass
    @abstractmethod
    def visit_assign_expr(self, expr: 'AssignExpr'):
        pass
    @abstractmethod
    def visit_logical_expr(self, expr: 'LogicalExpr'):
        pass
    @abstractmethod
    def visit_call_expr(self, expr: 'CallExpr'):
        pass

class StmtVisitor(ABC):
    @abstractmethod
    def visit_program_stmt(self, stmt: 'Program'):
        pass
    @abstractmethod
    def visit_expression_stmt(self, stmt: 'ExpressionStmt'):
        pass
    @abstractmethod
    def visit_print_stmt(self, stmt: 'PrintStmt'):
        pass
    @abstractmethod
    def visit_var_decl_stmt(self, stmt: 'VarDeclStmt'):
        pass
    @abstractmethod
    def visit_block_stmt(self, stmt: 'BlockStmt'):
        pass
    @abstractmethod
    def visit_if_stmt(self, stmt: 'IfStmt'):
        pass
    @abstractmethod
    def visit_while_stmt(self, stmt: 'WhileStmt'):
        pass
    @abstractmethod
    def visit_def_stmt(self, stmt: 'DefStmt'):
        pass
    @abstractmethod
    def visit_return_stmt(self, stmt: 'ReturnStmt'):
        pass

# --- Statement Node Definitions ---

class Program(Stmt):
    """AST node for the entire script (a list of statements)."""
    def __init__(self, statements: list[Stmt], line: int):
        self.statements = statements
        self.line = line # Line of the *end* of the program
        
    def accept(self, visitor: StmtVisitor):
        return visitor.visit_program_stmt(self)

class ExpressionStmt(Stmt):
    """AST node for a standalone expression (e.g., '1 + 2;')."""
    def __init__(self, expression: Expr, line: int):
        self.expression = expression
        self.line = line
        
    def accept(self, visitor: StmtVisitor):
        return visitor.visit_expression_stmt(self)

class PrintStmt(Stmt):
    """AST node for a 'print' statement."""
    def __init__(self, expression: Expr, line: int):
        self.expression = expression
        self.line = line
        
    def accept(self, visitor: StmtVisitor):
        return visitor.visit_print_stmt(self)

class VarDeclStmt(Stmt):
    """AST node for a 'var' declaration."""
    def __init__(self, name: Token, initializer: Expr | None, line: int):
        self.name = name
        self.initializer = initializer
        self.line = line
        
    def accept(self, visitor: StmtVisitor):
        return visitor.visit_var_decl_stmt(self)

class BlockStmt(Stmt):
    """AST node for a code block '{ ... }'."""
    def __init__(self, statements: list[Stmt], line: int):
        self.statements = statements
        self.line = line # Line of the closing '}'
        
    def accept(self, visitor: StmtVisitor):
        return visitor.visit_block_stmt(self)

class IfStmt(Stmt):
    """AST node for an 'if-else' statement."""
    def __init__(self, condition: Expr, then_branch: Stmt, else_branch: Stmt | None, line: int):
        self.condition = condition
        self.then_branch = then_branch
        self.else_branch = else_branch
        self.line = line
        
    def accept(self, visitor: StmtVisitor):
        return visitor.visit_if_stmt(self)

class WhileStmt(Stmt):
    """AST node for a 'while' loop."""
    def __init__(self, condition: Expr, body: Stmt, line: int):
        self.condition = condition
        self.body = body
        self.line = line
        
    def accept(self, visitor: StmtVisitor):
        return visitor.visit_while_stmt(self)

class DefStmt(Stmt):
    """AST node for a function declaration 'def ...'."""
    def __init__(self, name: Token, params: list[Token], body: BlockStmt, line: int):
        self.name = name
        self.params = params
        self.body = body
        self.line = line
        
    def accept(self, visitor: StmtVisitor):
        return visitor.visit_def_stmt(self)

class ReturnStmt(Stmt):
    """AST node for a 'return' statement."""
    def __init__(self, value: Expr | None, line: int):
        self.value = value
        self.line = line
        
    def accept(self, visitor: StmtVisitor):
        return visitor.visit_return_stmt(self)
        
# --- Expression Node Definitions ---

class Binary(Expr):
    """AST node for a binary operation (e.g., '+', '==')."""
    def __init__(self, left: Expr, operator: Token, right: Expr, line: int):
        self.left = left
        self.operator = operator
        self.right = right
        self.line = line

    def accept(self, visitor: ExprVisitor):
        return visitor.visit_binary_expr(self)

class Unary(Expr):
    """AST node for a unary operation (e.g., '-', '!')."""
    def __init__(self, operator: Token, right: Expr, line: int):
        self.operator = operator
        self.right = right
        self.line = line

    def accept(self, visitor: ExprVisitor):
        return visitor.visit_unary_expr(self)

class Literal(Expr):
    """AST node for a literal value (number, string, bool, nil)."""
    def __init__(self, value: any, line: int):
        self.value = value
        self.line = line

    def accept(self, visitor: ExprVisitor):
        return visitor.visit_literal_expr(self)

class Grouping(Expr):
    """AST node for a parenthesized expression '(...)'."""
    def __init__(self, expression: Expr, line: int):
        self.expression = expression
        self.line = line

    def accept(self, visitor: ExprVisitor):
        return visitor.visit_grouping_expr(self)

class VariableExpr(Expr):
    """AST node for a variable access (e.g., 'my_var')."""
    def __init__(self, name: Token, line: int):
        self.name = name
        self.line = line
        
    def accept(self, visitor: ExprVisitor):
        return visitor.visit_variable_expr(self)

class AssignExpr(Expr):
    """AST node for a variable assignment (e.g., 'my_var = 1')."""
    def __init__(self, name: Token, value: Expr, line: int):
        self.name = name
        self.value = value
        self.line = line
        
    def accept(self, visitor: ExprVisitor):
        return visitor.visit_assign_expr(self)

class LogicalExpr(Expr):
    """AST node for 'and' or 'or' (handles short-circuiting)."""
    def __init__(self, left: Expr, operator: Token, right: Expr, line: int):
        self.left = left
        self.operator = operator
        self.right = right
        self.line = line
        
    def accept(self, visitor: ExprVisitor):
        return visitor.visit_logical_expr(self)

class CallExpr(Expr):
    """AST node for a function call."""
    def __init__(self, callee: Expr, arguments: list[Expr], line: int):
        self.callee = callee
        self.arguments = arguments
        self.line = line
        
    def accept(self, visitor: ExprVisitor):
        return visitor.visit_call_expr(self)


