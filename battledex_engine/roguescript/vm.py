"""
The RogueScript Virtual Machine.

Executes bytecode Chunks generated by the Compiler.
This is a simple stack-based VM.
"""

from .bytecode import Chunk, OpCode
from .compiler import Compiler, CompileError
from .parser import Parser, ParseError
from .lexer import Lexer
from .errors import RogueScriptRuntimeError
from enum import Enum

class InterpretResult(Enum):
    OK = auto()
    COMPILE_ERROR = auto()
    RUNTIME_ERROR = auto()

class VirtualMachine:
    """The engine that runs RogueScript bytecode."""
    
    # Set a hard limit for the stack size
    STACK_MAX = 256 

    def __init__(self):
        self.chunk: Chunk = None
        self.ip: int = 0 # Instruction Pointer
        self.stack: list[any] = []
        self._ip_stack_map: dict[int, list[any]] = {}

    def interpret(self, source: str) -> (InterpretResult, any):
        """
        The main public-facing method.
        Compiles and runs a script, returning the result.
        """
        try:
            lexer = Lexer(source)
            tokens = lexer.get_all_tokens()
            
            parser = Parser(tokens)
            program = parser.parse()

            compiler = Compiler()
            chunk = compiler.compile(program)
            
            if chunk is None:
                return (InterpretResult.COMPILE_ERROR, None)
            
            self.chunk = chunk
            self.ip = 0
            self.stack = []
            
            result, value = self.run()
            return (result, value)

        except (ParseError, CompileError) as e:
            print(e)
            return (InterpretResult.COMPILE_ERROR, None)
        except RogueScriptRuntimeError as e:
            print(e)
            return (InterpretResult.RUNTIME_ERROR, None)
            
    def run(self) -> (InterpretResult, any):
        """The main execution loop of the VM."""
        
        while True:
            # --- Debugging ---
            # self._debug_trace_execution()
            
            instruction = self._read_byte()
            op = OpCode(instruction) # Convert int back to OpCode

            if op == OpCode.OP_RETURN:
                # Script is done, return the top value
                final_value = self.pop()
                return (InterpretResult.OK, final_value)
            
            elif op == OpCode.OP_PUSH_CONST:
                constant = self._read_constant()
                self.push(constant)
                
            elif op == OpCode.OP_NEGATE:
                self.push(-self.pop()) # Add type checking later
            
            elif op == OpCode.OP_NOT:
                # We'll define 'falsy' as False and nil
                value = self.pop()
                self.push(value is False or value is None)
            
            # --- Binary Ops ---
            # A macro-like helper could clean this up, but
            # this is clearer for now.
            elif op == OpCode.OP_ADD:
                b = self.pop()
                a = self.pop()
                self.push(a + b) # Add type checking later
            elif op == OpCode.OP_SUBTRACT:
                b = self.pop()
                a = self.pop()
                self.push(a - b)
            elif op == OpCode.OP_MULTIPLY:
                b = self.pop()
                a = self.pop()
                self.push(a * b)
            elif op == OpCode.OP_DIVIDE:
                b = self.pop()
                a = self.pop()
                if b == 0:
                    return self._runtime_error("Division by zero.")
                self.push(a / b)
                
    # --- Stack Helpers ---
    
    def push(self, value: any):
        if len(self.stack) >= self.STACK_MAX:
            raise RogueScriptRuntimeError("Stack overflow.", self._current_line())
        self.stack.append(value)
        
    def pop(self) -> any:
        if not self.stack:
            raise RogueScriptRuntimeError("Stack underflow.", self._current_line())
        return self.stack.pop()

    # --- Bytecode Reader Helpers ---

    def _read_byte(self) -> int:
        byte = self.chunk.code[self.ip]
        self.ip += 1
        return byte

    def _read_constant(self) -> any:
        const_index = self._read_byte()
        return self.chunk.constants[const_index]

    # --- Error and Debugging ---
    
    def _current_line(self) -> int:
        # Get line number for the *previous* instruction
        return self.chunk.lines[self.ip - 1]

    def _runtime_error(self, message: str) -> (InterpretResult, any):
        line = self._current_line()
        raise RogueScriptRuntimeError(message, line)

    def _debug_trace_execution(self):
        """A useful debug print-out for tracing."""
        # Save stack state for this IP
        self._ip_stack_map[self.ip] = list(self.stack)
        
        # Disassemble the instruction
        op_line = f"[IP {self.ip:04d}] "
        op_code = OpCode(self.chunk.code[self.ip])
        
        if op_code == OpCode.OP_RETURN:
            op_line += "OP_RETURN"
        elif op_code == OpCode.OP_PUSH_CONST:
            const_index = self.chunk.code[self.ip + 1]
            value = self.chunk.constants[const_index]
            op_line += f"OP_PUSH_CONST ({const_index}) -> {value}"
        else:
            op_line += op_code.name
            
        print(f"{op_line:<40} STACK: {self.stack}")

